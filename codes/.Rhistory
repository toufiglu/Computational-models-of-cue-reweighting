range.lapse_rate <- c(0, 1)
range.beta_pi <- c(10^-3, 10^2)
## parameters for normalization model
range.prior_kappa.normalization <- c(1, 10000)
get_exposure_data <- function(input_data, Condition, n.subject=1) {
input_data %<>% left_join(F0_reference, by='f0') %>% left_join(VOT_reference, by='VOT')
input_data %<>%
mutate(Condition=Condition,
Item.Type=Condition,
Item.Category = case_when(
VOT %in% c(-20, -10, 0) ~ "/b/",
TRUE ~ "/p/")) %>%
select(-VOT, -f0, -f0_Mel) %>%
rename(VOT = VOT_centered,
f0_Mel = F0_centered) %>%
crossing(Subject = factor(1:n.subject)) %>%
mutate(Subject = paste(Condition, Subject, sep = "."),
Phase = 'training',
x = map2(VOT, f0_Mel, ~ c("VOT" = .x, "f0_Mel" = .y))) %>%
mutate(ItemID=as.character(row_number()))
return(input_data)
}
canonical <- tribble(
~VOT, ~f0,
-20, 230,
-10, 220,
-10, 230,
-10, 240,
0, 230,
20, 290,
30, 280,
30, 290,
30, 300,
40, 290
)
neutral = tribble(
~VOT, ~f0,
-20, 260,
-10, 250,
-10, 260,
-10, 270,
0, 260,
20, 260,
30, 250,
30, 260,
30, 270,
40, 260
)
reversed = tribble(
~VOT, ~f0,
-20, 290,
-10, 280,
-10, 290,
-10, 300,
0, 290,
20, 230,
30, 220,
30, 230,
30, 240,
40, 230
)
d.IH.canonical <- get_exposure_data(canonical, Condition='canonical')
d.IH.neutral <- get_exposure_data(neutral, Condition='neutral')
d.IH.reversed <- get_exposure_data(reversed, Condition='reversed')
names(d.IH.canonical$x) <- NULL
names(d.IH.neutral$x) <- NULL
names(d.IH.reversed$x) <- NULL
cues <- c('VOT', 'f0_Mel')
m.VOT_f0_MVG_canonical <- make_MVG_from_data(data=d.IH.canonical,category="Item.Category",cues=cues)
m.VOT_f0_MVG_neutral <- make_MVG_from_data(data=d.IH.neutral,category = "Item.Category",cues=cues)
m.VOT_f0_MVG_reversed <- make_MVG_from_data(data=d.IH.reversed,category = "Item.Category",cues=cues)
n.subject=1
d.IH.test <- tibble(
VOT = 22,
f0_Mel = c(199,269)
) %>%
mutate(Phase='test',
Item.Category=NA,
Item.Intended_category = case_when(
f0_Mel==199 ~ '/b/',
TRUE ~ '/p/'),
x=map2(VOT, f0_Mel, ~ c("VOT" = .x, "f0_Mel" = .y)),
Item.Type='test',
Block=1) %>%
crossing(Condition='test') %>%
mutate(Subject=paste(Condition, n.subject, sep = ".")) %>%
mutate(ItemID=as.character(row_number()))
basic_IH_result_plot <- function(data) {
data %>%
ggplot(aes(x = Condition, y = prob.p, group = normalised_F0)) +
list(
geom_point(position = position_dodge(width = 0.2), size = 1, aes(shape = normalised_F0, color = normalised_F0)),
scale_color_manual(values = c("red", "blue")),
coord_cartesian(ylim = c(0, 1.1)),
scale_y_continuous(breaks = c(0, 0.5, 1)),
scale_x_discrete(labels= c("canonical", "neutral", "reversed")),
xlab("Exposure condition"),
ylab("proportion of /p/ response"),
theme(
legend.key.height= duo.panel.key,
legend.position = "top",
axis.text.x = element_text(angle = 22.5, hjust = 1, size = 7),
axis.text.y = element_text(size = 7),
axis.title.x = element_text(size = 7, face = "bold"),
axis.title.y = element_text(size = 7, face = "bold"),
legend.text = element_text (size = 7),
legend.title = element_text(size = 7, face = "bold"),
plot.title = element_text(size = 7),
panel.grid.major.x = element_blank())
)
}
update_representations_and_categorize_test <- function(
prior,
exposure,
test,
cues = c("VOT", "f0_Mel")
) {
update_NIW_ideal_adaptor_incrementally(
prior = prior,
exposure = exposure,
exposure.category = "Item.Category",
exposure.cues = cues,
noise_treatment = "marginalize",
lapse_treatment = "marginalize",
method = "label-certain",
keep.update_history = FALSE,
keep.exposure_data = FALSE) %>%
nest(posterior = everything()) %>%
add_test_and_categorize(test)
}
get_representation_models_for_plot <- function(
prior_kappa = prior_kappa.plot,
prior_nu = prior_nu.plot,
d.IH.exposure,
ideal_adaptor,
type
){
all_representations <- list()
Condition = d.IH.exposure$Condition[[1]]
if (RESET_MODELS || !file.exists(get_path(paste0("../models/d.IH.results.representations_", example_label, "_", Condition, "_", type, ".rds")))){
for(i in 1:10){  # Loop to iterate 10 times
if(i == 1){
# Use the ideal adaptor for the first iteration
m.ia.VOT_f0.IH.plot_sample <- ideal_adaptor
} else {
# Use the posterior from the previous iteration for the subsequent iteration
m.ia.VOT_f0.IH.plot_sample <-
posterior_model_previous <- all_representations[[i-1]] %>%
mutate_at(vars(starts_with("prior_")), ~as.numeric(as.character(.x))) %>%
filter(Item.Intended_category == "/p/") %>%
select(prior_kappa, prior_nu, posterior) %>%
unnest(posterior) %>%
arrange(category)
}
representations.pred <-
d.IH.exposure %>%
nest(data = -c(Condition, Subject)) %>%
crossing(
m.ia.VOT_f0.IH.plot_sample %>%
nest(prior = -c(prior_kappa, prior_nu))) %>%
group_by(Condition, Subject, prior_kappa, prior_nu) %>%
group_modify(~ update_representations_and_categorize_test(prior = .x$prior[[1]], exposure = .x$data[[1]], test = d.IH.test)) %>%
mutate_at(vars(starts_with("prior_")), ~factor(.x)) %>%
mutate_at(vars(starts_with("prior_")), fct_rev) %>%
ungroup() %>%
mutate(Iteration = i)
# Ensure to add the result to the all_representations list
all_representations[[i]] <- representations.pred
saveRDS(all_representations, get_path(paste0("../models/d.IH.results.representations_", example_label, "_", Condition, "_", type, ".rds")))
}
}
else {
all_representations <- readRDS(get_path(paste0("../models/d.IH.results.representations_", example_label, "_", Condition, "_", type, ".rds")))
}
return(all_representations)
}
#get results for independent and sequential models
#(as canonical trials are the first block, no sequential model for canonical is needed.)
representation.IH.canonical.independent <- get_representation_models_for_plot(d.IH.exposure = d.IH.canonical, ideal_adaptor=m.ia.VOT_f0.IH, type="independent")
#get the posterior of results before being passed into the sequential model
model.for.sequential <- function(representation.model) {
representation.model <- representation.model %>%
mutate_at(vars(starts_with("prior_")), ~as.numeric(as.character(.x))) %>%
filter(Item.Intended_category == "/p/") %>%
select(prior_kappa, prior_nu, posterior) %>%
unnest(posterior)
}
#neutral
representation.IH.neutral.independent <- get_representation_models_for_plot(d.IH.exposure = d.IH.neutral, ideal_adaptor=m.ia.VOT_f0.IH, type="independent")
representation.IH.neutral.sequential <- get_representation_models_for_plot(d.IH.exposure = d.IH.neutral, ideal_adaptor=model.for.sequential(representation.IH.canonical.independent[[10]]), type="sequential")
#reversed
representation.IH.reversed.independent <- get_representation_models_for_plot(d.IH.exposure = d.IH.reversed, ideal_adaptor=m.ia.VOT_f0.IH, type="independent")
representation.IH.reversed.sequential <- get_representation_models_for_plot(d.IH.exposure = d.IH.reversed, ideal_adaptor=model.for.sequential(representation.IH.neutral.sequential[[10]]), type="sequential")
#make tibbles for plots
representation.independent <- rbind(representation.IH.canonical.independent[[10]], representation.IH.neutral.independent[[10]], representation.IH.reversed.independent[[10]]) %>%
mutate(prob.p = ifelse(Item.Intended_category =="/p/", response, 1-response),
normalised_F0 = ifelse(Item.Intended_category =="/p/", 269, 199),
normalised_F0 = factor(normalised_F0))
representation.sequential <- rbind(representation.IH.canonical.independent[[10]], representation.IH.neutral.sequential[[10]], representation.IH.reversed.sequential[[10]]) %>%
mutate(prob.p = ifelse(Item.Intended_category =="/p/", response, 1-response),
normalised_F0 = ifelse(Item.Intended_category =="/p/", 269, 199),
normalised_F0 = factor(normalised_F0))
update_representations_and_categorize_test <- function(
prior,
exposure,
test,
cues = c("VOT", "f0_Mel")
) {
update_NIW_ideal_adaptor_incrementally(
prior = prior,
exposure = exposure,
exposure.category = "Item.Category",
exposure.cues = cues,
noise_treatment = "marginalize",
lapse_treatment = "marginalize",
method = "label-certain",
keep.update_history = FALSE,
keep.exposure_data = FALSE) %>%
nest(posterior = everything()) %>%
add_test_and_categorize(test)
}
get_representation_models_for_plot <- function(
prior_kappa = prior_kappa.plot,
prior_nu = prior_nu.plot,
d.IH.exposure,
ideal_adaptor,
type
){
all_representations <- list()
Condition = d.IH.exposure$Condition[[1]]
if (RESET_MODELS || !file.exists(get_path(paste0("../models/d.IH.results.representations_", example_label, "_", Condition, "_", type, ".rds")))){
for(i in 1:10){  # Loop to iterate 10 times
if(i == 1){
# Use the ideal adaptor for the first iteration
m.ia.VOT_f0.IH.plot_sample <- ideal_adaptor
} else {
# Use the posterior from the previous iteration for the subsequent iteration
m.ia.VOT_f0.IH.plot_sample <-
posterior_model_previous <- all_representations[[i-1]] %>%
mutate_at(vars(starts_with("prior_")), ~as.numeric(as.character(.x))) %>%
filter(Item.Intended_category == "/p/") %>%
select(prior_kappa, prior_nu, posterior) %>%
unnest(posterior) %>%
arrange(category)
}
representations.pred <-
d.IH.exposure %>%
nest(data = -c(Condition, Subject)) %>%
crossing(
m.ia.VOT_f0.IH.plot_sample %>%
nest(prior = -c(prior_kappa, prior_nu))) %>%
group_by(Condition, Subject, prior_kappa, prior_nu) %>%
group_modify(~ update_representations_and_categorize_test(prior = .x$prior[[1]], exposure = .x$data[[1]], test = d.IH.test)) %>%
mutate_at(vars(starts_with("prior_")), ~factor(.x)) %>%
mutate_at(vars(starts_with("prior_")), fct_rev) %>%
ungroup() %>%
mutate(Iteration = i)
# Ensure to add the result to the all_representations list
all_representations[[i]] <- representations.pred
saveRDS(all_representations, get_path(paste0("../models/d.IH.results.representations_", example_label, "_", Condition, "_", type, ".rds")))
}
}
else {
all_representations <- readRDS(get_path(paste0("../models/d.IH.results.representations_", example_label, "_", Condition, "_", type, ".rds")))
}
return(all_representations)
}
#get results for independent and sequential models
#(as canonical trials are the first block, no sequential model for canonical is needed.)
representation.IH.canonical.independent <- get_representation_models_for_plot(d.IH.exposure = d.IH.canonical, ideal_adaptor=m.ia.VOT_f0.IH, type="independent")
#get the posterior of results before being passed into the sequential model
model.for.sequential <- function(representation.model) {
representation.model <- representation.model %>%
mutate_at(vars(starts_with("prior_")), ~as.numeric(as.character(.x))) %>%
filter(Item.Intended_category == "/p/") %>%
select(prior_kappa, prior_nu, posterior) %>%
unnest(posterior)
}
#neutral
representation.IH.neutral.independent <- get_representation_models_for_plot(d.IH.exposure = d.IH.neutral, ideal_adaptor=m.ia.VOT_f0.IH, type="independent")
representation.IH.neutral.sequential <- get_representation_models_for_plot(d.IH.exposure = d.IH.neutral, ideal_adaptor=model.for.sequential(representation.IH.canonical.independent[[10]]), type="sequential")
#reversed
representation.IH.reversed.independent <- get_representation_models_for_plot(d.IH.exposure = d.IH.reversed, ideal_adaptor=m.ia.VOT_f0.IH, type="independent")
representation.IH.reversed.sequential <- get_representation_models_for_plot(d.IH.exposure = d.IH.reversed, ideal_adaptor=model.for.sequential(representation.IH.neutral.sequential[[10]]), type="sequential")
#make tibbles for plots
representation.independent <- rbind(representation.IH.canonical.independent[[10]], representation.IH.neutral.independent[[10]], representation.IH.reversed.independent[[10]]) %>%
mutate(prob.p = ifelse(Item.Intended_category =="/p/", response, 1-response),
normalised_F0 = ifelse(Item.Intended_category =="/p/", 269, 199),
normalised_F0 = factor(normalised_F0))
representation.sequential <- rbind(representation.IH.canonical.independent[[10]], representation.IH.neutral.sequential[[10]], representation.IH.reversed.sequential[[10]]) %>%
mutate(prob.p = ifelse(Item.Intended_category =="/p/", response, 1-response),
normalised_F0 = ifelse(Item.Intended_category =="/p/", 269, 199),
normalised_F0 = factor(normalised_F0))
categories.IH <- c("/b/", "/p/")
make_results_plot_representations <- function(data) {
p.results <-
basic_IH_result_plot(data) +
facet_grid(
prior_nu ~ prior_kappa,
labeller = label_bquote(
cols = {kappa[.(categories.IH[1])~","~0] == kappa[.(categories.IH[2])~","~0]} == .(as.character(prior_kappa)),
rows = {nu[.(categories.IH[1])~","~0] == nu[.(categories.IH[2])~","~0]} == .(as.character(prior_nu)))) +
ggh4x::force_panelsizes(cols = result.panel.size, rows = result.panel.size)
}
p.representation.independent <- make_results_plot_representations(representation.independent)
p.representation.sequential <- make_results_plot_representations(representation.sequential)
p.representation.independent
p.representation.sequential
p.representation.independent
representation.IH.pretraining
d.IH.pretraining <- d.IH.canonical %>%
mutate(Condition='pretraining')
representation.IH.pretraining <- get_representation_models_for_plot(
d.IH.exposure = d.IH.pretraining,
prior_kappa = 10000,
prior_nu = 10000,
ideal_adaptor=m.ia.VOT_f0.IH,
type="independent")
representation.initial <- representation.IH.pretraining[[10]] %>%
mutate(prob.p = ifelse(category=='/p/', response, 1-response),
normalised_F0 = ifelse(category=='/p/', 269, 199),
normalised_F0 = factor(normalised_F0)) %>%
ggplot(aes(x = "pretraining", y = prob.p, group = normalised_F0)) +
geom_point(aes(shape = normalised_F0), size = 3) +
theme(legend.text = element_text (size = 12),
legend.title = element_text(size = 12, face = "bold"),
plot.title = element_text(size = 12),
axis.text.y = element_text(size = 10),
axis.text.x = element_text(size = 12),
axis.title = element_text(size = 12, face = "bold")) +
xlab("Condition") + ylab("Probability of /p/ responses") +
coord_cartesian(ylim = c(0, 1))
representation.initial
representation.IH.pretraining
m.ia.VOT_f0.IH
m.ia.VOT_f0.IH.pretraining <-
crossing(
prior_kappa = 10000,
prior_nu = 10000) %>%
rowwise() %>%
mutate(ideal_adaptor = map2(prior_kappa, prior_nu, ~ make_stop_VOTf0_ideal_adaptor(m = m.io.VOT_f0.IH, kappa = .x, nu = .y))) %>%
unnest(ideal_adaptor) %>%
arrange(category)
m.ia.VOT_f0.IH.pretraining
representation.IH.pretraining <- get_representation_models_for_plot(
d.IH.exposure = d.IH.pretraining,
prior_kappa = 10000,
prior_nu = 10000,
ideal_adaptor=m.ia.VOT_f0.IH.pretraining,
type="independent")
representation.initial <- representation.IH.pretraining[[10]] %>%
mutate(prob.p = ifelse(category=='/p/', response, 1-response),
normalised_F0 = ifelse(category=='/p/', 269, 199),
normalised_F0 = factor(normalised_F0)) %>%
ggplot(aes(x = "pretraining", y = prob.p, group = normalised_F0)) +
geom_point(aes(shape = normalised_F0), size = 3) +
theme(legend.text = element_text (size = 12),
legend.title = element_text(size = 12, face = "bold"),
plot.title = element_text(size = 12),
axis.text.y = element_text(size = 10),
axis.text.x = element_text(size = 12),
axis.title = element_text(size = 12, face = "bold")) +
xlab("Condition") + ylab("Probability of /p/ responses") +
coord_cartesian(ylim = c(0, 1))
representation.initial
update_normalization_and_categorize_test <- function(
prior,
mu_0 = first(prior_marginal_VOT_f0_stats$x_mean),
kappa.normalization,
exposure,
test
) {
# Get normalization parameters for exposure data
exposure.normalization <-
exposure %>%
summarise(
x_N = length(x),
x_mean = list(colMeans(reduce(x, rbind))),
x_cov = list(cov(reduce(x, rbind))))
# Apply normalization based on exposure to test
mu_inferred <- 1 /
(kappa.normalization + exposure.normalization$x_N[[1]]) *
(kappa.normalization * mu_0 + exposure.normalization$x_N[[1]] * exposure.normalization$x_mean[[1]])
test %<>%
mutate(
x_unnormalized = x,
x = map(x, ~ .x - (mu_inferred - mu_0)))
test %>%
select(x_unnormalized, x, Item.Intended_category) %>%
nest(x = x, Item.Intended_category = c(x, Item.Intended_category, x_unnormalized)) %>%
mutate(posterior = list(prior)) %>%
# Don't add test again since it's already in the data
add_test_and_categorize(test = NULL)
}
get_normalization_models_for_plot <- function(
prior_kappa.normalization = c(4, 16, 64, 256, 1024),
d.IH.exposure,
normalization.prior,
type
){
all_normalizations <- list()  # Create an empty list to store results from each iteration
Condition = d.IH.exposure$Condition[[1]]
if (RESET_MODELS || !file.exists(get_path(paste0("../models/d.IH.results.normalization_", example_label, "_", Condition, "_", type, ".rds")))){
for(i in 1:10){  # Loop to iterate 10 times
if(i == 1){
normalization.adaptor <-  normalization.prior
} else {
normalization.adaptor <- all_normalizations[[i-1]]
}
normalization.adaptor <- normalization.adaptor %>%
filter(Item.Intended_category == "/p/") %>%
select(prior_kappa.normalization, posterior) %>%
rename(prior=posterior)
normalization.pred <-
d.IH.exposure %>%
nest(data = -c(Condition, Subject)) %>%
crossing(prior_kappa.normalization = normalization.adaptor$prior_kappa.normalization,
prior = normalization.adaptor$prior) %>%
mutate(prior_kappa.normalization = as.numeric(as.character(prior_kappa.normalization))) %>%
group_by(Condition, Subject, prior_kappa.normalization) %>%
group_modify(
~ update_normalization_and_categorize_test(
prior = .x$prior[[1]],
kappa.normalization = .y$prior_kappa.normalization,
exposure = .x$data[[1]],
test = d.IH.test)) %>%
mutate_at(vars(starts_with("prior_")), ~factor(.x)) %>%
mutate_at(vars(starts_with("prior_")), fct_rev) %>%
ungroup()
all_normalizations[[i]] <- normalization.pred
}
saveRDS(all_normalizations, get_path(paste0("../models/d.IH.results.normalization_", example_label, "_", Condition, "_", type, ".rds")))
} else {
all_normalizations <- readRDS(get_path(paste0("../models/d.IH.results.normalization_", example_label, "_", Condition, "_", type, ".rds")))
}
return(all_normalizations)
}
m.ia.VOT_f0.IH.normalization <- m.ia.VOT_f0.IH %>%
filter(prior_kappa == max(prior_kappa) & prior_nu == max(prior_nu)) %>%
nest(posterior = everything()) %>%
crossing(prior_kappa.normalization = c(4, 16, 64, 256, 1024)) %>%
mutate(Item.Intended_category="/p/",
prior_kappa.normalization = factor(prior_kappa.normalization))
# specify what parameters to plot
# canonical, again, independent only
d.IH.normalization.canonical.independent <- get_normalization_models_for_plot(d.IH.exposure=d.IH.canonical, normalization.prior=m.ia.VOT_f0.IH.normalization, type="independent")
# neutral
d.IH.normalization.neutral.independent <- get_normalization_models_for_plot(d.IH.exposure=d.IH.neutral, normalization.prior=m.ia.VOT_f0.IH.normalization, type="independent" )
d.IH.normalization.neutral.sequential <- get_normalization_models_for_plot(d.IH.exposure=d.IH.neutral, normalization.prior=d.IH.normalization.canonical.independent[[10]], type="sequential")
d.IH.normalization.reversed.independent <- get_normalization_models_for_plot(d.IH.exposure=d.IH.reversed, normalization.prior=m.ia.VOT_f0.IH.normalization, type="independent")
d.IH.normalization.reversed.sequential <- get_normalization_models_for_plot(d.IH.exposure=d.IH.reversed, normalization.prior=d.IH.normalization.neutral.sequential[[10]], type="sequential")
normalisation.independent <- rbind(d.IH.normalization.canonical.independent[[10]],
d.IH.normalization.neutral.independent[[10]],
d.IH.normalization.reversed.independent[[10]]) %>%
mutate(prob.p = ifelse(Item.Intended_category =="/p/", response, 1-response),
normalised_F0 = ifelse(Item.Intended_category =="/p/", 269, 199),
normalised_F0 = factor(normalised_F0))
normalisation.sequential <- rbind(d.IH.normalization.canonical.independent[[10]],
d.IH.normalization.neutral.sequential[[10]],
d.IH.normalization.reversed.sequential[[10]]) %>%
mutate(prob.p = ifelse(Item.Intended_category =="/p/", response, 1-response),
normalised_F0 = ifelse(Item.Intended_category =="/p/", 269, 199),
normalised_F0 = factor(normalised_F0))
make_results_plot_normalization <- function(data){
p.results <-
basic_IH_result_plot(data) +
facet_grid(
. ~ prior_kappa.normalization,
labeller = label_bquote(
cols = ~kappa[0] == .(as.character(prior_kappa.normalization)))) +
ggh4x::force_panelsizes(cols = result.panel.size, rows = result.panel.size)
}
p.normalisation.independent <- make_results_plot_normalization(normalisation.independent)
p.normalisation.sequential <- make_results_plot_normalization(normalisation.sequential)
p.normalisation.independent
p.normalisation.sequential
m.ia.VOT_f0.IH.pretraining.normalization <- m.ia.VOT_f0.IH.pretraining %>%
nest(posterior = everything()) %>%
crossing(prior_kappa.normalization = c(4, 16, 64, 256, 1024)) %>%
mutate(Item.Intended_category="/p/",
prior_kappa.normalization = factor(prior_kappa.normalization))
m.ia.VOT_f0.IH.pretraining.normalization <- m.ia.VOT_f0.IH.pretraining %>%
m.ia.VOT_f0.IH.pretraining.normalization <- m.ia.VOT_f0.IH.pretraining %>%
nest(posterior = everything()) %>%
crossing(prior_kappa.normalization = 10000) %>%
mutate(Item.Intended_category="/p/",
prior_kappa.normalization = factor(prior_kappa.normalization))
m.ia.VOT_f0.IH.pretraining.normalization <- m.ia.VOT_f0.IH.pretraining %>%
nest(posterior = everything()) %>%
crossing(prior_kappa.normalization = 10000) %>%
mutate(Item.Intended_category="/p/",
prior_kappa.normalization = factor(prior_kappa.normalization))
d.IH.normalization.pretraining <-
get_normalization_models_for_plot(
d.IH.exposure=d.IH.pretraining,
type="independent",
normalization.prior=m.ia.VOT_f0.IH.pretraining.normalization)
normalization.plot <- d.IH.normalization.pretraining[[10]] %>%
mutate(prob.p = ifelse(Item.Intended_category=='/p/', response, 1-response),
normalised_F0 = ifelse(Item.Intended_category=='/p/', 269, 199),
normalised_F0 = factor(normalised_F0)) %>%
ggplot(aes(x = Condition, y = prob.p, group = normalised_F0)) +
geom_point(aes(shape = normalised_F0), size = 3) +
theme(legend.text = element_text (size = 12),
legend.title = element_text(size = 12, face = "bold"),
plot.title = element_text(size = 12),
axis.text.y = element_text(size = 10),
axis.text.x = element_text(size = 12),
axis.title = element_text(size = 12, face = "bold")) +
xlab("Condition") + ylab("Probability of /p/ responses") +
coord_cartesian(ylim = c(0, 1))
normalization.plot
